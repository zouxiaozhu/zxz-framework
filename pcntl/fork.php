<?php
$pid = pcntl_fork();

//父进程和子进程都会执行下面代码
if ($pid == -1) {
    //错误处理：创建子进程失败时返回-1.
    die('could not fork');
} else if ($pid) {
    //父进程会得到子进程号，所以这里是父进程执行的逻辑
//    pcntl_wait($status); //等待子进程中断，防止子进程成为僵尸进程。
    sleep(5);
} else {
    //子进程得到的$pid为0, 所以这里是子进程执行的逻辑。
    echo 111 . PHP_EOL;
    echo getmypid() . PHP_EOL;
    echo pcntl_getpriority(getmypid()); // 优先级  越小优先级越高
    sleep(11);
//    pcntl_signal_dispatch — 调用等待信号的处理器

}

// 这里特殊备注 子进程和父进程同时执行 逻辑块中的代码
// 然后都会 执行逻辑块之外的代码 也就是下面的代码都会执行
// 如果不想让子进程执行下面的代码 那么可以exit()
echo (getmypid()) . PHP_EOL . '1';

/**
 *
 * todo
 * 僵尸进程
 *
 * 在Linux进程的状态中，僵尸进程（Zombie）是非常特殊的一种，
 * 它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，
 * 仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，
 * 除此之外，僵尸进程不再占有任何内存空间.当一个进程结束了，而它的父进程没有等待它（wait/waitpid），
 * 那么它将会成为僵尸进程，僵尸进程不断累积会导致系统因为没有更多可用的进程号而无法创建新的进程.
 */

/**
 *
 * todo
 * 勿在PHP WEB开发中试图通过PCNTL使用多进程！
 */
